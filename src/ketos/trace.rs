//! Provides facilities for expressing and storing tracebacks.
//!
//! When a compilation or execution operation returns an error, it will store
//! a traceback within thread-local storage. To access this value, the
//! functions `get_traceback` (which clones the value) and `take_traceback`
//! (which removes the value) can be used.

use std::cell::RefCell;
use std::fmt;
use std::mem::replace;

use name::{Name, NameDisplay, NameStore};

/// Represents a series of items, beginning with the outermost context
/// and culminating with the context in which an error was generated.
#[derive(Clone)]
pub struct Trace {
    items: Vec<TraceItem>,
}

impl Trace {
    /// Creates a new `Trace` from a series of items.
    pub fn new(items: Vec<TraceItem>) -> Trace {
        Trace{items: items}
    }

    /// Creates a new `Trace` from a single item.
    pub fn single(item: TraceItem) -> Trace {
        Trace::new(vec![item])
    }

    /// Returns the series of traced items.
    pub fn get_items(&self) -> &[TraceItem] {
        &self.items
    }
}

thread_local!(static TRACEBACK: RefCell<Option<Trace>> = RefCell::new(None));

/// Removes the traceback value for the current thread.
pub fn clear_traceback() {
    TRACEBACK.with(|tb| *tb.borrow_mut() = None);
}

/// Clones and returns the traceback value for the current thread.
///
/// The value remains stored for future calls to `get_traceback`.
pub fn get_traceback() -> Option<Trace> {
    TRACEBACK.with(|tb| tb.borrow().clone())
}

/// Assigns a traceback value for the current thread.
pub fn set_traceback(trace: Trace) {
    TRACEBACK.with(|tb| *tb.borrow_mut() = Some(trace));
}

/// Removes and returns the traceback value for the current thread.
pub fn take_traceback() -> Option<Trace> {
    TRACEBACK.with(|tb| replace(&mut *tb.borrow_mut(), None))
}

/// Represents a single traceable event in either compilation or
/// execution of code.
#[derive(Copy, Clone, Debug)]
pub enum TraceItem {
    /// Call to a code object; `(scope name, code name)`
    CallCode(Name, Name),
    /// Call to a code object generated by an expression
    CallExpr(Name),
    /// Call to an anonymous function
    CallLambda(Name),
    /// Call to a macro; `(scope name, macro name)`
    CallMacro(Name, Name),
    /// Expansion of an operator; `(scope name, operator name)`
    CallOperator(Name, Name),
    /// Call to a system function
    CallSys(Name),
    /// Definition of a named value; `(scope name, definition name)`
    Define(Name, Name),
    /// Definition of a constant value; `(scope name, const name)`
    DefineConst(Name, Name),
    /// Definition of an anonymous lambda
    DefineLambda(Name),
    /// Definition of a macro; `(scope name, macro name)`
    DefineMacro(Name, Name),
    /// Definition of a structure; `(scope name, struct name)`
    DefineStruct(Name, Name),
    /// Module import declaration; `(scope name, module name)`
    UseModule(Name, Name),
}

impl NameDisplay for Trace {
    fn fmt(&self, names: &NameStore, f: &mut fmt::Formatter) -> fmt::Result {
        use self::TraceItem::*;

        for item in &self.items {
            match *item {
                CallCode(m, n) => try!(writeln!(f,
                    "  In {}, function {}", names.get(m), names.get(n))),
                CallExpr(m) => try!(writeln!(f,
                    "  In {}, call expression", names.get(m))),
                CallLambda(m) => try!(writeln!(f,
                    "  In {}, lambda", names.get(m))),
                CallMacro(m, n) => try!(writeln!(f,
                    "  In {}, macro {}", names.get(m), names.get(n))),
                CallOperator(m, n) => try!(writeln!(f,
                    "  In {}, operator {}", names.get(m), names.get(n))),
                CallSys(n) => try!(writeln!(f,
                    "  In system function {}", names.get(n))),
                Define(m, n) => try!(writeln!(f,
                    "  In {}, define {}", names.get(m), names.get(n))),
                DefineConst(m, n) => try!(writeln!(f,
                    "  In {}, const {}", names.get(m), names.get(n))),
                DefineLambda(m) => try!(writeln!(f,
                    "  In {}, lambda", names.get(m))),
                DefineMacro(m, n) => try!(writeln!(f,
                    "  In {}, macro {}", names.get(m), names.get(n))),
                DefineStruct(m, n) => try!(writeln!(f,
                    "  In {}, struct {}", names.get(m), names.get(n))),
                UseModule(m, n) => try!(writeln!(f,
                    "  In {}, use {}", names.get(m), names.get(n))),
            }
        }

        Ok(())
    }
}
